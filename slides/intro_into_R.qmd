---
title: "Intro intro R"
author: Raphael Rehms, Jonathan Christ
format: 
  revealjs:
    scrollable: true
    theme: solarized # moon
    transition: slide
    footer: "Intro intro R"
    slide-number: c
    include-after-body: clean_title_page.html
    fontsize: 25pt
    highlight-style: github
execute: 
  echo: true
editor: 
  markdown: 
    wrap: 72
---

# Orga

## Parts

Combination of

-   Slides

    -   "lecture like"

    -   New content, Theoretical part

-   Exercises

    -   Hands-on

    -   Dedicated time during the course

    -   "Interactive"

## Passing this course?

-   Passing this course is mandatory for the QM exam

-   Hand in the **data project** ([**Deadline 22. December
    2024**]{style="color:red;"})

    -   In the data project you proof, that you are able to conduct a
        statistical analysis in `R`

    -   Should have the form of a *report using **Quarto** or
        **Markdown***

# Intro

## Why R?

Why R?

-   R is **open source**

-   All techniques for data analyses

-   State-of-the-art graphics capabilities

-   A platform for programming new statistical methods or analysis
    pipelines (in form of R-packages)

## Programming (in general)

*"Good programmers are made, not born."* (Gerald M. Weinberg - The
Psychology of Computer Programming)

-   consequence I

    train...

-   consequence II

    train...

-   consequence III

    train more

Hands-on is important. Understanding is less that 30%

## R and R Studio

Required tools for the course:

-   Programming language R

    -   designed to make fast prototyping for statistical analysis
    -   interpreted language

-   RStudio (optional, but recommended)

    -   IDE tailored for `R`

    -   Integrates a lot more (e.g. python, c++, etc.)

## R packages

-   `R` comes with many useful packages by default

-   However, the strength lies in the huge collection of external
    packages

-   Most popular and default: [**CRAN**](https://cran.r-project.org/)

-   Install new packages in R using either

    -   using a command:

        -   `install.packages("<package-name>")`
            (e.g.`install.packages("mvtnorm")`)

    -   RStudio

        -   using built-in tools from the IDE

# Basic operations

## Addition, subtraction, etc

```{r}
1+2
1-2
1*2
1/2
1^2
```

::: callout-note
What will happen?
```{r, eval=FALSE}
1/0
```
:::




## Special symbols functions

Special symbols

```{r, eval=FALSE}
pi
Inf
```

Mathematical functions

```{r}
exp(1)
log(1)
```

Special cases:


-   `NaN` is a data type that indicates an invalid number.
```{r}
log(-1)
NaN + 1
```

-   `NA` is a missing value.
```{r}
NA + 1
```




## Assigning objects

Assignment is done using `<-`

```{r}
x <- 1
y <- 2
x + y
```

Alternatively, use `=`

```{r}
x = sqrt(2)
y = sqrt(2)
x * y
```

[Look at environment pane in R Studio, what can you
see?]{style="color:blue;"}

## Naming objects

-   Objects in `R` have to start with a letter

Case sensitive

```{r}
a <- 2
A <- 1
a-a
```

Overwrite variables with old ones

```{r}
a <- a + 1
```

Combination of words

```{r}
variable_name <- 1
variable.name <- 1
variableName <- 1
```

## Comments

Sometimes it is useful, to comment code. Use a `#` to comment

Standard:

```{r}
1+1
```

Comment a line (no output):

```{r}
# 1+1
```

Comment after an expression (only `1+1` gets evaluated):

```{r}
1+1 # +1
```

## Function calling

So far we used expressions like `f(...)`. This is a **function**. E.g.

```{r, eval=FALSE}
exp(2)
```

We call the function `exp` with a value of 2. Or the (natural)
logarithm:

```{r}
log(exp(1))
```

We can specify the base as a *second argument*:

```{r}
log(2, 2)
```


::: callout-note
What will happen?
```{r, eval=FALSE}
Log(Exp(1))
```
:::





## Get documentation

Access the documentation using

-   `<F1>`

-   type `?function_name`

-   use RStudio functionality

E.g. documentation for `log()` reveals that we calculate the natural
logarithm.

```{r, echo=T, eval=FALSE}
?log
log(x, base = exp(1))
```

## Function calling cont'd

You can ignore the argument name, when placements are clear. - We have
done that for `exp` and `log`

Hence, this here

```{r, eval=FALSE}
log(2, 2)
```

means, that we actually call

```{r, eval=FALSE}
log(x=2, base=2)
```

If you specify the argument, order does not matter.

Example:

```{r, eval=FALSE}
log(base=3, x=2)
log(3, 2)
```

::: callout-note
What will happen?
```{r, eval=FALSE}
log <- 1
log(log)
```
:::




## Basic (primitive) data types

#### `numeric`

A (floating point) number. We used this so far (default).

`1.0, 1.34, -33, pi`

<hr>

#### `logical`

A binary data type.

`TRUE, FALSE, T, F`

<hr>

#### `integer`

Can be specified using an "L".

`1L, 100L, -99L`

<hr>

#### `character`

Represents letters OR sentences.

`'a', "abc", "May the force be with you"`




# Exercise 1



# Vectors



## Vectors

You can *combine* single values to a *vector.*

```{r}
a <- c(1,2,3,4)
a

b <- c(TRUE, FALSE, TRUE)
b

c <- c("a", 'ab', "ab c")
c


```

Many operations in R are *vectorized*

```{r}
a + a
a * a
exp(a)
-a
```

::: callout-note
What will happen?
```{r, eval=FALSE}
c("1",2,3)
```
:::




## Automatic recycling

```{r}
a <- c(1,2,3,4)
a + 1

b <- c(2,2)
a + b
```

::: callout-warning
Note the behavior for for vectors with different length! Example:

```{r, warning=TRUE}
a <- c(1,2,3)
b <- c(1,2)
a + b
```
:::





## Vector creation

There are a lot of convenience functions to create vectors.

```{r}
c(1,2,3,4)
1:4
seq(4)
```

More complex ones:

```{r}
4:-3
seq(-10, 10, by = 2)
seq(-10, 10, length.out = 10) # vector of length 10
```





## Select elements of a vector

**Access elements of a vector using positional numbers within `[...]`:**
```{r}
x <- c(2,4,2,5)
x[1]
```

Multiple elements
```{r}
selection <- c(1,4)
x[selection]
x[c(1,4)]
```

Negative values will be excluded
```{r}
x[-c(1,3)]
```


::: callout-note
What will happen?
```{r, eval=FALSE}
x[1:5]
x[-(5:10)]
```
:::



## Logical values for comparison

Recall the very most basic data type `logical`, i.e. `TRUE` and `FALSE`.

-   We can create such an object by comparison:
```{r}
1 == 2  # lhs equal rhs?
1 != 2  # lhs unequal rhs?
1 > 2  # lhs larger rhs?
1 >= 2  # lhs larger or equal rhs?
1 < 2  # lhs less than rhs?
1 <= 2  # lhs less or equal than rhs?
```

Swap value:
```{r}
!TRUE
!FALSE
```



::: callout-note
What will happen?
```{r, eval=FALSE}
1 == "1"
1 != NaN 
NA == NA  # we will learn the solution in a few slides
```
:::




## Filter elements of a vector

Comparison operators are vectorized:
```{r}
c(T,F,T) == c(F,F,T)  # element-wise comparison
```


Check condition on a numeric vector
```{r}
x <- c(2,4,2,5)
position_two <- x == 2  # logical vector showing, where the condition holds
position_two
```


**Use logical values to filter a vector.**
```{r}
x[position_two]
# or dictly
x[x == 2]
```

Filter for values less than 3
```{r}
x[x < 3]
```


## Combine filters with `&` and `|`

Combination operations...
```{r}
TRUE & TRUE
FALSE & TRUE
TRUE | TRUE
FALSE | TRUE
```

...or vectorized
```{r}
x <- c(T,F,T,F)
y <- c(T,T,F,F)
x & y
x | y
```




## Vector operations
```{r}
x <- c(1,1,2,3)
length(x)
append(x, c(1,2,3))
rev(x)
sort(x)
unique(x)
sum(x) 
```






# Exercise 2

# Complex structures


## Factors

## Vector, Matrix, Array

## List

## Data Frame
