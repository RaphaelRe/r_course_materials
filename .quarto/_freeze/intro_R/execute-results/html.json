{
  "hash": "53d79fcf6abfe5c50e5a9eb2c26bb0b9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Intro intro R\"\nauthor: Raphael Rehms\nformat: \n  revealjs:\n    scrollable: true\n    theme: solarized # moon\n    transition: slide\n    footer: \"Intro intro R\"\n    slide-number: c\n    include-after-body: clean_title_page.html\n    fontsize: 25pt\n    highlight-style: github\nexecute: \n  echo: true\n  freeze: auto\neditor: \n  markdown: \n    wrap: 72\n---\n\n\n\n\n# Orga\n\n## Parts\n\nCombination of\n\n-   Slides\n\n    -   \"lecture like\"\n\n    -   New content, Theoretical part\n\n-   Exercises\n\n    -   Hands-on\n\n    -   Dedicated time during the course\n\n    -   \"Interactive\"\n\n<!-- ## Passing this course? -->\n<!---->\n<!-- -   Passing this course is mandatory for the QM exam -->\n<!---->\n<!-- -   Hand in the **data project** ([**Deadline 22. December -->\n<!--     2024**]{style=\"color:red;\"}) -->\n<!---->\n<!--     -   In the data project you proof, that you are able to conduct a -->\n<!--         statistical analysis in `R` -->\n<!---->\n<!--     -   Should have the form of a *report using **Quarto** or -->\n<!--         **Markdown*** -->\n\n# Intro\n\n## Why R?\n\nWhy R?\n\n-   R is **open source**\n\n-   All techniques for data analyses\n\n-   State-of-the-art graphics capabilities\n\n-   A platform for programming new statistical methods or analysis\n    pipelines (in form of R-packages)\n\n## Programming (in general)\n\n*\"Good programmers are made, not born.\"* (Gerald M. Weinberg - The\nPsychology of Computer Programming)\n\n-   consequence I\n\n    train...\n\n-   consequence II\n\n    train...\n\n-   consequence III\n\n    train more\n\nHands-on is important. Understanding is less that 30%\n\n## R and R Studio\n\nRequired tools for the course:\n\n-   Programming language R\n\n    -   designed to make fast prototyping for statistical analysis\n    -   interpreted language\n\n-   RStudio (optional, but recommended)\n\n    -   IDE tailored for `R`\n\n    -   Integrates a lot more (e.g. python, c++, etc.)\n\n## R packages\n\n-   `R` comes with many useful packages by default\n\n-   However, the strength lies in the huge collection of external\n    packages\n\n-   Most popular and default: [**CRAN**](https://cran.r-project.org/)\n\n-   Install new packages in R using either\n\n    -   using a command:\n\n        -   `install.packages(\"<package-name>\")`\n            (e.g.`install.packages(\"mvtnorm\")`)\n\n    -   RStudio\n\n        -   using built-in tools from the IDE\n\n# Basic operations\n\n## Addition, subtraction, etc\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1+2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\n1-2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1\n```\n\n\n:::\n\n```{.r .cell-code}\n1*2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\n1/2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5\n```\n\n\n:::\n\n```{.r .cell-code}\n1^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\n::: callout-note\nWhat will happen?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1/0\n```\n:::\n\n\n\n:::\n\n\n\n\n## Special symbols functions\n\nSpecial symbols\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npi\nInf\n```\n:::\n\n\n\n\nMathematical functions\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexp(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.718282\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n\n\nSpecial cases:\n\n\n-   `NaN` is a data type that indicates an invalid number.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(-1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n\n```{.r .cell-code}\nNaN + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n:::\n\n\n\n\n-   `NA` is a missing value.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNA + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\n\n\n-   `NULL` means literally empty/nothing\n\n\n## Assigning objects\n\nAssignment is done using `<-`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1\ny <- 2\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\n\nAlternatively, use `=`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = sqrt(2)\ny = sqrt(2)\nx * y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n[Look at environment pane in R Studio, what can you\nsee?]{style=\"color:blue;\"}\n\n## Naming objects\n\n-   Objects in `R` have to start with a letter\n\nCase sensitive\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 2\nA <- 1\na-a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n\n\nOverwrite variables with old ones\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- a + 1\n```\n:::\n\n\n\n\nCombination of words\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvariable_name <- 1\nvariable.name <- 1\nvariableName <- 1\n```\n:::\n\n\n\n\n## Comments\n\nSometimes it is useful, to comment code. Use a `#` to comment\n\nStandard:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1+1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\nComment a line (no output):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1+1\n```\n:::\n\n\n\n\nComment after an expression (only `1+1` gets evaluated):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1+1 # +1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n## Function calling\n\nSo far we used expressions like `f(...)`. This is a **function**. E.g.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexp(2)\n```\n:::\n\n\n\n\nWe call the function `exp` with a value of 2. Or the (natural)\nlogarithm:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(exp(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\nWe can specify the base as a *second argument*:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(2, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\n\n::: callout-note\nWhat will happen?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nLog(Exp(1))\n```\n:::\n\n\n\n:::\n\n\n\n\n\n## Get documentation\n\nAccess the documentation using\n\n-   `<F1>`\n\n-   type `?function_name`\n\n-   use RStudio functionality\n\nE.g. documentation for `log()` reveals that we calculate the natural\nlogarithm.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?log\nlog(x, base = exp(1))\n```\n:::\n\n\n\n\n## Function calling cont'd\n\nYou can ignore the argument name, when placements are clear. - We have\ndone that for `exp` and `log`\n\nHence, this here\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(2, 2)\n```\n:::\n\n\n\n\nmeans, that we actually call\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(x=2, base=2)\n```\n:::\n\n\n\n\nIf you specify the argument, order does not matter.\n\nExample:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(base=3, x=2)\nlog(3, 2)\n```\n:::\n\n\n\n\n::: callout-note\nWhat will happen?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog <- 1\nlog(log)\n```\n:::\n\n\n\n:::\n\n\n\n\n## Basic (primitive) data types\n\n#### `numeric`\n\nA (floating point) number. We used this so far (default).\n\n`1.0, 1.34, -33, pi`\n\n<hr>\n\n#### `logical`\n\nA binary data type.\n\n`TRUE, FALSE, T, F`\n\n<hr>\n\n#### `integer`\n\nCan be specified using an \"L\".\n\n`1L, 100L, -99L`\n\n<hr>\n\n#### `character`\n\nRepresents letters OR sentences.\n\n`'a', \"abc\", \"May the force be with you\"`\n\n\n\n\n# Exercise 1\n\n\n\n# Vectors\n\n\n\n## Vectors\n\nYou can *combine* single values to a *vector.*\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(1,2,3,4)\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\nb <- c(TRUE, FALSE, TRUE)\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nc <- c(\"a\", 'ab', \"ab c\")\nc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\"    \"ab\"   \"ab c\"\n```\n\n\n:::\n:::\n\n\n\n\nMany operations in R are *vectorized*\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na + a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4 6 8\n```\n\n\n:::\n\n```{.r .cell-code}\na * a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  4  9 16\n```\n\n\n:::\n\n```{.r .cell-code}\nexp(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2.718282  7.389056 20.085537 54.598150\n```\n\n\n:::\n\n```{.r .cell-code}\n-a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1 -2 -3 -4\n```\n\n\n:::\n:::\n\n\n\n\n::: callout-note\nWhat will happen?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"1\",2,3)\n```\n:::\n\n\n\n:::\n\n\n\n\n## Automatic recycling\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(1,2,3,4)\na + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nb <- c(2,2)\na + b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4 5 6\n```\n\n\n:::\n:::\n\n\n\n\n::: callout-warning\nNote the behavior for for vectors with different length! Example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(1,2,3)\nb <- c(1,2)\na + b\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in a + b: longer object length is not a multiple of shorter object\nlength\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4 4\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n\n\n\n## Vector creation\n\nThere are a lot of convenience functions to create vectors.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1,2,3,4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\n1:4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n:::\n\n\n\n\nMore complex ones:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n4:-3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  4  3  2  1  0 -1 -2 -3\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(-10, 10, by = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -10  -8  -6  -4  -2   0   2   4   6   8  10\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(-10, 10, length.out = 10) # vector of length 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -10.000000  -7.777778  -5.555556  -3.333333  -1.111111   1.111111\n [7]   3.333333   5.555556   7.777778  10.000000\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n## Select elements of a vector\n\n**Access elements of a vector using positional numbers within `[...]`:**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(2,4,2,5)\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\nMultiple elements\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselection <- c(1,4)\nx[selection]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 5\n```\n\n\n:::\n\n```{.r .cell-code}\nx[c(1,4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 5\n```\n\n\n:::\n:::\n\n\n\n\nNegative values will be excluded\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[-c(1,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 5\n```\n\n\n:::\n:::\n\n\n\n\n\n::: callout-note\nWhat will happen?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[1:5]\nx[-(5:10)]\nx[0]\n```\n:::\n\n\n\n:::\n\n\n\n## Logical values for comparison\n\nRecall the very most basic data type `logical`, i.e. `TRUE` and `FALSE`.\n\n-   We can create such an object by comparison:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 == 2  # lhs equal rhs?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n1 != 2  # lhs unequal rhs?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n1 > 2  # lhs larger rhs?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n1 >= 2  # lhs larger or equal rhs?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n1 < 2  # lhs less than rhs?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n1 <= 2  # lhs less or equal than rhs?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\nSwap value:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n!TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n!FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: callout-note\nWhat will happen?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 == \"1\"\n1 != NaN \nNA == NA  # we will learn the solution in a few slides\n```\n:::\n\n\n\n:::\n\n\n\n\n## Filter elements of a vector\n\nComparison operators are vectorized:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(T,F,T) == c(F,F,T)  # element-wise comparison\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\nCheck condition on a numeric vector\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(2,4,2,5)\nposition_two <- x == 2  # logical vector showing, where the condition holds\nposition_two\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n**Use logical values to filter a vector.**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[position_two]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 2\n```\n\n\n:::\n\n```{.r .cell-code}\n# or dictly\nx[x == 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 2\n```\n\n\n:::\n:::\n\n\n\n\nFilter for values less than 3\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[x < 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 2\n```\n\n\n:::\n:::\n\n\n\n\n\n## Combine filters with `&` and `|`\n\nCombination operations...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE & TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nFALSE & TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nFALSE | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n...or vectorized\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(T,F,T,F)\ny <- c(T,T,F,F)\nx & y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nx | y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n\nUse this to filter a vector for multiple conditions\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[(x < 5) & (x > 2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlogical(0)\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Assign new values in a vector\n\nWe can assign new values to a vector using a combination of selection and assignment\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:5\nx[1] <- 2\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nx[x > 3] <- -99\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   2   2   3 -99 -99\n```\n\n\n:::\n\n```{.r .cell-code}\nx[-1] <- 100\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   2 100 100 100 100\n```\n\n\n:::\n:::\n\n\n\n\n\n::: callout-note\nWhat will happen?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[100] <- 1\n```\n:::\n\n\n\n:::\n\n\n\n\n\n## Vector operations\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1,1,2,3)\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nappend(x, c(1,2,3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1 2 3 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nrev(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 2 1 1\n```\n\n\n:::\n\n```{.r .cell-code}\nsort(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nunique(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(x) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n# Exercise 2\n\n\n\n\n\n\n\n# Complex structures\n\n\n## Factors\nConsider a vector, that represents a categorical variable. Let's say colors.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolors <- c(\"blue\", \"red\", \"blue\", \"red\", \"green\", \"black\", \"green\", \"white\")\ncolors\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"blue\"  \"red\"   \"blue\"  \"red\"   \"green\" \"black\" \"green\" \"white\"\n```\n\n\n:::\n:::\n\n\n\n\nWe cast `colors` into a factor now:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolors <- as.factor(colors)\ncolors\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] blue  red   blue  red   green black green white\nLevels: black blue green red white\n```\n\n\n:::\n\n```{.r .cell-code}\nlevels(colors)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"black\" \"blue\"  \"green\" \"red\"   \"white\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas.numeric(colors)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4 2 4 3 1 3 5\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(colors)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(colors)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\n\nHence, a vector of integeres where each value corresponds to a character value.\n\n\n\n\n## Complex data structures \n\n![from *Ceballos and Cardiel, (2013). Data structure – First Steps in R. Retreived 25-11-2018\nfrom http:// venus.ifca.unican.es/ Rintro.2024*](dataStructuresNew.png)\n\n<br>\n\n\n**Use `str(...)` to inspect the structure of complex data types!**\n\n\n\n## Vector, Matrix, Array\n\nWe already got vectors. Lets combine them:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:4\n(x_rbind <- cbind(x,x)) # 4 rows, 2 columns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     x x\n[1,] 1 1\n[2,] 2 2\n[3,] 3 3\n[4,] 4 4\n```\n\n\n:::\n\n```{.r .cell-code}\n(x_cbind <- rbind(x,x)) # 2 rows, 4 columns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [,1] [,2] [,3] [,4]\nx    1    2    3    4\nx    1    2    3    4\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(x_rbind)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 2\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(x_cbind)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(x_rbind)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nncol(x_rbind)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n\n## Vector, Matrix, Array cont'd\n\nWe can define a matrix using the `matrix` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(1:6, nrow = 3, ncol = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n\n\n:::\n\n```{.r .cell-code}\nmatrix(1:6, nrow = 3, ncol = 2, byrow = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]    5    6\n```\n\n\n:::\n:::\n\n\n\n\n**Arrays as a generalization with multiple dimensions**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narray(1:12, dim = c(3,2,2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n, , 2\n\n     [,1] [,2]\n[1,]    7   10\n[2,]    8   11\n[3,]    9   12\n```\n\n\n:::\n:::\n\n\n\n\nThis is also sometimes called a *tensor*.\n\n\n\n\n## Select/filter elements on Arrays\n\nAs vectors, we can select and filter. Seperate dimensions with a `,`, i.e. `[... , ...]` \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(m <- matrix(1:6, nrow = 3, ncol = 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n\n\n:::\n\n```{.r .cell-code}\nm[2,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\nm[nrow(m), ncol(m) ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n\n\nDefining no entry will return the full dimension:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm[2,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 5\n```\n\n\n:::\n\n```{.r .cell-code}\nm[,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\n\n\n\n::: callout-note\nWhat will happen?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm[1,,2]\nm[10]\n```\n:::\n\n\n\n:::\n\n\n\n\n\n\n## List\n\nA list is a collection of elements. These elements could be any object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(l <- list(1, \"2\", 1:3, list(m)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"2\"\n\n[[3]]\n[1] 1 2 3\n\n[[4]]\n[[4]][[1]]\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n\n\n:::\n:::\n\n\n\n\nAccess elements of a list with `[[...]]`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2\"\n```\n\n\n:::\n:::\n\n\n\n\nA sub-list can be accessed with  `[...]`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"2\"\n\n[[3]]\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## List cont'd\nYou can define names for lists:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl <- list(slot1 = 1:3, slot2 = c(\"a\", \"b\"), slot3 = l)\nnames(l)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"slot1\" \"slot2\" \"slot3\"\n```\n\n\n:::\n:::\n\n\n\n\nAccess list elements using the name and a `$`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl$slot3 # return the original list l before overwriting it\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"2\"\n\n[[3]]\n[1] 1 2 3\n\n[[4]]\n[[4]][[1]]\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n\n\n:::\n:::\n\n\n\n\nDelete elements by assigning a `NULL` to a slot\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl[2:3] <- NULL\nl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$slot1\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Data Frame\n\nA data frame is basically a list, where each element is a vector of the same length.\nHowever, it implements function to handle it as a matrix.\n\nLet's define a data set representing cars:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol <- as.factor(c(\"blue\", \"red\", \"blue\", \"red\", \"green\", \"black\", \"green\", \"white\"))\npri <- c(10, 20, 9, 50, 0.4, 15, 160, 60) * 1000\nis_el <- c(F,F,F,T,F,T,F,T)\n\ncar_ds <- data.frame(color = col, price = pri, is_electric = is_el)\ncar_ds\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  color  price is_electric\n1  blue  10000       FALSE\n2   red  20000       FALSE\n3  blue   9000       FALSE\n4   red  50000        TRUE\n5 green    400       FALSE\n6 black  15000        TRUE\n7 green 160000       FALSE\n8 white  60000        TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(car_ds)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t8 obs. of  3 variables:\n $ color      : Factor w/ 5 levels \"black\",\"blue\",..: 2 4 2 4 3 1 3 5\n $ price      : num  10000 20000 9000 50000 400 15000 160000 60000\n $ is_electric: logi  FALSE FALSE FALSE TRUE FALSE TRUE ...\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Data Frame cont'd\n\nWe can work on a data set as we work with a matrix\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# All rows with red cars\ncar_ds[car_ds$color == \"red\", ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  color price is_electric\n2   red 20000       FALSE\n4   red 50000        TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# price of all black cars\ncar_ds[car_ds$color == \"black\", \"price\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15000\n```\n\n\n:::\n\n```{.r .cell-code}\n# set a new price for the last car in the ds\ncar_ds[8, 2] <- 600\ncar_ds\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  color  price is_electric\n1  blue  10000       FALSE\n2   red  20000       FALSE\n3  blue   9000       FALSE\n4   red  50000        TRUE\n5 green    400       FALSE\n6 black  15000        TRUE\n7 green 160000       FALSE\n8 white    600        TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n## More on data structures\n\n-   A data frame behaves like a matrix.\n-   However, keep in mind that it is actually a list.\nWe can easily prove that:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.list(car_ds)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\nUse `str(...)` to check the data structure of *any* object:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(car_ds)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t8 obs. of  3 variables:\n $ color      : Factor w/ 5 levels \"black\",\"blue\",..: 2 4 2 4 3 1 3 5\n $ price      : num  10000 20000 9000 50000 400 15000 160000 600\n $ is_electric: logi  FALSE FALSE FALSE TRUE FALSE TRUE ...\n```\n\n\n:::\n\n```{.r .cell-code}\nm <- matrix(1:4, ncol = 2)\nstr(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n int [1:2, 1:2] 1 2 3 4\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n## Load data\n\nWe can load a data set from a package using `data(...)`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"iris\", package = \"datasets\")  # look in the environment variables\n```\n:::\n\n\n\n\nWe can load data from files. Use `read.table(...)`, or wrapper functions with reasonable default values. E.g. We can read a file directly from the web:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- read.csv(\"https://raw.githubusercontent.com/vincentarelbundock/Rdatasets/master/csv/datasets/mtcars.csv\")\nhead(d)  # show the first few lines of a data set\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           rownames  mpg cyl disp  hp drat    wt  qsec vs am gear carb\n1         Mazda RX4 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n2     Mazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n3        Datsun 710 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n4    Hornet 4 Drive 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n5 Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n6           Valiant 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n```\n\n\n:::\n:::\n\n\n\n\nNote, that we can also use this to read a data set from a local directory! To do that we have to specify either the full path or define the path from the **working directory**. Use `getwd(...)` and `setwd(...)` to get or set the current working directory. See next slide for an example.\n\n\n##  Save data sets\nConsider a data set, you have worked with. You can save it using write functions.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite.csv(car_ds, file = \"example_data.csv\")  # we save our data set in the current working directory\n```\n:::\n\n\n\n\nWe can again read the data as a new object:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_loaded <- read.csv(\"example_data.csv\")\n\nall.equal(car_ds,d_loaded)  # test whether 2 (more complex) R object are the same\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Names: 3 string mismatches\"                          \n[2] \"Length mismatch: comparison on first 3 components\"   \n[3] \"Component 1: 'current' is not a factor\"              \n[4] \"Component 2: Modes: numeric, character\"              \n[5] \"Component 2: target is numeric, current is character\"\n[6] \"Component 3: Modes: logical, numeric\"                \n[7] \"Component 3: target is logical, current is numeric\"  \n```\n\n\n:::\n:::\n\n\n\n\n\n[**We can read other files as well. E.g. excel, SPSS, SAS, etc.**]{style=\"color:blue;\"}\n\nThere are a lot of packages to do that. \n\n[I use the function `load(...)` from the `rio` package that tries to unify a lot of different formats.]{style=\"color:rgba(255, 99, 71, 0.5);\"})\n\n\n\n## Save and load R objects\n\nSo far, we only worked with data frames for read and write operations. \nWe can save general `R` objects using `save(...)` and `load(...)` using the `.RData` format.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na_list <- list(a = 42, data = iris, comment = \"whatever\")\n\nsave(a_list, file = \"example_object.RData\")\n\nload(\"example_object.RData\")\n```\n:::\n",
    "supporting": [
      "intro_R_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}